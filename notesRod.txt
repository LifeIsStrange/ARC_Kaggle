IDEAS:

add function to startOps + Crop: 624, 588

- replicateShape + scaling, changing color
- 194: crop, minimize, 
- 108: symmetrize, colormap, deleteshape
- 424, 475, 498, 624: replicate + crop

- can i remove the line to crop the largest shape? i think i can for 133 but what about 28
- 774 add cropshape options???

- delete shapes: 654, 96, 129 (holes)
- symmetrize: 61
- arrange: 558, 440, 438, 414
should be solved: 30 cropshape, 36 connect all pixekls,

------------ArrangeShapes---------
solves: 152, 440, 558, 588, 622
ignore grid + lay: 414
overlap: 21, 498 , 589
fit + smth:
	- scale: 158, 760, 535
	- color change: 237
tesselate + rotations:
	- 252, 263, 676
lay + smth:
	- color change 523
	- delete largest 652
replicate + cropLargest: 365, 624

------------DeleteShapes-----------

solves: 96, 652

TODOs:
- Get attributes betters
- when to call

------------Replicate--------
TODOs:
- at pixels
- adopt anchor color

- 74, 88, 100, 108, 111, 116, 132, 157, 172, 190, 205, 207, 208, 274, 284, 326, 362, 365, 367, 369, 421, 424, 431, 464, 467, 472, 474, 475, 494, 497, 498, 500, 509, 514, 523, 524,539, 540, 583, 592, 626, 628, 636, 650, 659, 674, 683, 716, 742, 779, 786, 795

140, 

maybe 592?
add 'all' + context? eg 583

solved: 17,68,75,79,100,111,116,157,172,360,367,421,500,540,645
howtocall: 524

same:
- at pixels: 53, 74, 88, 509, 205, 424, 474, 628, 674, 716, 786
- slots: 68, 645, 367, 421, 524
- at subshapes: 132, 190, 196, 208, 659, 683, 779, 795
- everywhere: 207, 362, 539, 650
- symmetrize: 108, 284

reference:
- 626, 636, 742

other cases:
- 4, 583

---------Difference Matrix----------
453

------------References---------
reference:  142, 181, 205, 244q
other ref: 153, 158, 208, 223, 229, 389



------------Crop-------------
unsolved crop tasks:
[28,87,204,318,395,440,445,464,473,509,586,589,624,655,676,689,768,774]

CropShape:
- Identify if output is shape
- Identify if shape is in input
- Identify characteristic attributes
- Crop holes: 586, 354

solves: 13, 30, 35, 38, 48, 56, 78, 110, 120, 133, 173, 176, 206, 215, 216, 217, 258, 262, 270, 289, 299, 345, 364,  383, 488, 576, 578, 635, 712, 727, 785, 690(sort)
solves too: 28, 395

cropframe: 13, 204, 443
cropLargestNonbackgroudnFrame = 87, 194, 464
reference: 318, 690
cropsomething? 354, 365
color count in multicolor shapes: 473, 586(count holes?)	

something + cropshape: 424 (replicate), 440 (sort), 455 (overlap), 676 (encaixar)

color changes: 768, 774

OTHER: 589


--------overlapSubmatrices--------

DELTED PARTS:


#if candTask.outIsInMulticolorShapeSize:
        #    for attrs in [set(['UnSh']),set(['MoCo']),set(['MoCl']),set(['OneSh'])]:
        #        x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=False, diagonals=False))
        #else:
        #    for attrs in [set(['LaSh'])]:
        #        x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=True, diagonals=True))
       # if hasattr(candTask.outIsInMulticolorDShapeSize):
        #    for attrs in:
         #       x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=False, diagonals=True))




                      
    elif anchorType == 'subshape':
        for repShs in repList:
            for repSh in repShs:
                for sh2 in shList:
                    if sh2.isSubshape(repSh,sameColor=True,rotation=False,mirror=False) and len(sh2.pixels)<len(repSh.pixels):
                        for x in range((repSh.shape[0]-sh2.shape[0])+1):
                            for y in range((repSh.shape[1]-sh2.shape[1])+1):
                                if np.all(np.logical_or(sh2.m == 255, repSh.m[x: x+sh2.shape[0],y:y+sh2.shape[1]] == sh2.m)):
                                    #if np.all(np.logical_or(m[max(sh2.position[0]-x,0):min(sh2.position[0]-x+repSh.shape[0],m.shape[0]),\
                                    #                          max(sh2.position[1]-y,0):min(sh2.position[1]-y+repSh.shape[1],m.shape[1]] == matrix.backgroundColor),\)):
                                        newInsert = copy.deepcopy(repSh)
                                        newInsert.position = (sh2.position[0]-x, sh2.position[1]-y)
                                        if sh2.position[1]-y<0:
                                            newInsert.position = (sh2.position[0], 0)
                                            newInsert.m = newInsert.m[::,y-sh2.position[1]:]
                                            newInsert.shape = newInsert.m.shape
                                        if sh2.position[0]-x<0:
                                            newInsert.position = (0, sh2.position[1])
                                            newInsert.m = newInsert.m[x-sh2.position[0]:,:]
                                            newInsert.shape = newInsert.m.shape
                                        m=insertShape(m, newInsert)




%%%%%%%%%%%%%%%%%%%%%%%%%



def replicateShapes(matrix, attributes=None, diagonal=False, multicolor=True, anchorType=None, anchorColor=0,\
                    mirror=None, rotate=0, allCombs=False, scale=False, deleteOriginal=False, adoptAnchorColor=False):
    m = matrix.m.copy()
    score = -1
    #first find the shape or shapes to replicate
    if diagonal:
        if multicolor:
            shList = matrix.multicolorDShapes
        else:
            shList = matrix.dShapes
    else:
        if multicolor:
            shList = matrix.multicolorShapes
        else:
            shList = matrix.shapes
    if attributes != None:
        repList = []
        attrList = matrix.getShapeAttributes(backgroundColor=matrix.backgroundColor,\
                                             singleColor=not multicolor, diagonals=diagonal)
        for shi in range(len(shList)):
            if len(attrList[shi].intersection(attributes)) > score:
                repList = [[shList[shi]]]
                score = len(attrList[shi].intersection(attributes))
            elif len(attrList[shi].intersection(attributes)) == score:
                repList += [[shList[shi]]]
        if len(repList) == 0:
            return m
    else:
        if multicolor:
            repList = [[sh] for sh in shList]
        else:
            repList = [[sh] for sh in shList if sh.color != matrix.backgroundColor]
    delList = [sh for sh in repList]
    if allCombs:
        newList = []
        for repShapes in repList:
            newSubList = []
            for repShape in repShapes:
                for r in range(0,4):
                    mr, mrM = np.rot90(repShape.m, r), np.rot90(repShape.m[::-1,::], r)
                    newRep, newRepM = copy.deepcopy(repShape), copy.deepcopy(repShape)
                    newRep.m, newRepM.m = mr, mrM
                    newRep.shape, newRepM.shape = mr.shape, mrM.shape
                    newSubList.append(newRep)
                    newSubList.append(newRepM)
            newList.append(newSubList)
        repList = newList
    
    elif mirror == 'lr' and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = repList[0][0].m[::,::-1]
        repList = [[newRep]]
    elif mirror == 'ud' and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = repList[0][0].m[::-1,::]
        repList = [[newRep]]
    elif rotate > 0 and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = np.rot90(repList[0][0].m,rotate)
        newRep.shape = newRep.m.shape
        repList = [[newRep]]
    if scale == True:
        newRepList=[]
        for sc in range(4,0,-1):    
            for repShape in repList:
                newRep = copy.deepcopy(repShape[0])
                newRep.m = np.repeat(np.repeat(repShape[0].m, sc, axis=1), sc, axis=0)
                newRep.shape = newRep.m.shape
                newRep.pixels = set([(i,j) for i,j in np.ndindex(newRep.m.shape) if newRep.m[i,j]!=255])
                newRepList.append(newRep)
        repList = [newRepList]
    if anchorType == 'all':
        repList.sort(key=lambda x: len(x[0].pixels), reverse=True)
    elif anchorType == 'subframe':
        repList.sort(key=lambda x: len(x[0].pixels))
    #then find places to replicate
    if anchorType == 'all':    
        for repShs in repList:
            for repSh in repShs:
                for j in range(matrix.shape[1] - repSh.shape[1]+1):
                    for i in range(matrix.shape[0] - repSh.shape[0]+1):
                        if np.all(np.logical_or(m[i:i+repSh.shape[0],j:j+repSh.shape[1]]==anchorColor,repSh.m==255)):
                            newInsert = copy.deepcopy(repSh)
                            newInsert.position = (i, j)
                            m = insertShape(m, newInsert)
                            
    elif anchorType == 'subframe':
        delList = []
        for sh2 in shList:
            if sh2 in repList:
                continue
            score, bestScore= 0, 0
            bestSh = None
            for repShs in repList:
                for repSh in repShs:
                    if sh2.isSubshape(repSh,sameColor=not adoptAnchorColor,rotation=False,mirror=False) and len(sh2.pixels)<len(repSh.pixels):
                        for x in range((repSh.shape[0]-sh2.shape[0])+1):
                            for y in range((repSh.shape[1]-sh2.shape[1])+1):
                                mAux = m[max(sh2.position[0]-x, 0):min(sh2.position[0]-x+repSh.shape[0], m.shape[0]), max(sh2.position[1]-y, 0):min(sh2.position[1]-y+repSh.shape[1], m.shape[1])]
                                shAux = repSh.m[max(0, x-sh2.position[0]):min(repSh.shape[0],m.shape[0]+x-sh2.position[0]),max(0, y-sh2.position[1]):min(repSh.shape[1],m.shape[1]+y-sh2.position[1])]
                                if np.all(np.logical_or(mAux==shAux, mAux == matrix.backgroundColor)):
                                    score = np.count_nonzero(mAux==shAux)
                                    if score > bestScore:
                                        bestScore = score
                                        bestX, bestY = sh2.position[0]-x, sh2.position[1]-y
                                        bestSh = copy.deepcopy(repSh)
            if bestSh != None:
                delList += [[bestSh]]
                newInsert = copy.deepcopy(bestSh)
                newInsert.position = (bestX, bestY)
                newInsert.shape = newInsert.m.shape
                m=insertShape(m, newInsert)
        #repList = [sh for sh in newRepList]
        
    if deleteOriginal:
        for shs in delList:
            for sh in shs:
                m = deleteShape(m, sh, matrix.backgroundColor)              
    return(m)