IDEAS:
CONFLICT DELETE SHAPES and CROPSHAPE, 776 s'hauria de solucionar. i altres tamb√©.....
219 same stuffff
add function to startOps + Crop: 624, 588

- replicateShape + changing color
- 194: crop, minimize, 
- 108: symmetrize, colormap, deleteshape
- 424, 475, 498, 624: replicate + crop

- can i remove the line to crop the largest shape? i think i can for 133 but what about 28
- 774 add cropshape options???

- delete shapes: 654, 96, 129 (holes)
- symmetrize: 61
- arrange: 438, 414

------------ArrangeShapes---------
solves: 152, 440, 558, 588, 622
ignore grid + lay: 414

455 (overlap), 676 (encaixar)

overlap: 21, 498 , 589
fit + smth:
	- scale: 158, 760, 535
	- color change: 237
tesselate + rotations:
	- 252, 263, 676
lay + smth:
	- color change 523
	- delete largest 652
replicate + cropLargest: 365, 624

------------DeleteShapes-----------
solves: 96, 652

TODOs:
- More examples
------------ColorByPixels------
353,415,523,768

todo 182
------------Symmetrize-----
solved: 26, 111, 116, 360
108,284,542
------------Replicate--------
TODOs:
- at pixels
- adopt anchor color

- 74, 88, 108, 111, 116, 132, 190, 205, 207, 208, 274, 284, 326, 362, 365, 367, 369, 424, 431, 464, 467, 472, 474, 475, 494, 497, 498, 509, 514, 523, 539, 583, 592, 626, 628, 636, 650, 659, 674, 683, 716, 742, 779, 786, 795

140, 

maybe 592?
add 'all' + context? eg 583

solved: 17,68,75,79,100,111,116,157,172,205,208,360,367,421,500,524,540,624,645

same:
- at pixels: 53, 74, 88, 509, 205, 424, 474, 628, 674, 716, 786
- at subshapes: 132, 190, 196, 659, 683, 779, 795
- everywhere: 207, 362, 539, 650
- symmetrize: 108, 284

reference:
- 626, 636, 742

other cases:
- 4, 583

---------Difference Matrix----------
453

------------References---------
reference:  142, 181, 205, 244q
other ref: 153, 158, 208, 223, 229, 389



------------Crop-------------
unsolved crop tasks:
[28,87,204,318,395,440,445,464,473,509,586,589,624,655,676,689,774]

CropShape:
- Identify if output is shape
- Identify if shape is in input
- Identify characteristic attributes
- Crop holes: 586, 354

solves: 13, 28, 30, 35, 38, 48, 56, 78, 110, 120, 133, 173, 176, 206, 215, 216, 217, 258, 262, 270, 289, 299, 345, 364,  383, 395,488, 576, 578, 635, 712, 727, 785, 690(sort)

cropframe: 13, 204, 443
cropLargestNonbackgroudnFrame = 87, 194, 464
reference: 318, 690
cropsomething? 354, 365
color count in multicolor shapes: 473, 586(count holes?)	


color changes: 768, 774

--------overlapSubmatrices--------

DELTED PARTS:


#if candTask.outIsInMulticolorShapeSize:
        #    for attrs in [set(['UnSh']),set(['MoCo']),set(['MoCl']),set(['OneSh'])]:
        #        x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=False, diagonals=False))
        #else:
        #    for attrs in [set(['LaSh'])]:
        #        x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=True, diagonals=True))
       # if hasattr(candTask.outIsInMulticolorDShapeSize):
        #    for attrs in:
         #       x.append(partial(cropShape, attributes=attrs, backgroundColor=0, singleColor=False, diagonals=True))




                      
    elif anchorType == 'subshape':
        for repShs in repList:
            for repSh in repShs:
                for sh2 in shList:
                    if sh2.isSubshape(repSh,sameColor=True,rotation=False,mirror=False) and len(sh2.pixels)<len(repSh.pixels):
                        for x in range((repSh.shape[0]-sh2.shape[0])+1):
                            for y in range((repSh.shape[1]-sh2.shape[1])+1):
                                if np.all(np.logical_or(sh2.m == 255, repSh.m[x: x+sh2.shape[0],y:y+sh2.shape[1]] == sh2.m)):
                                    #if np.all(np.logical_or(m[max(sh2.position[0]-x,0):min(sh2.position[0]-x+repSh.shape[0],m.shape[0]),\
                                    #                          max(sh2.position[1]-y,0):min(sh2.position[1]-y+repSh.shape[1],m.shape[1]] == matrix.backgroundColor),\)):
                                        newInsert = copy.deepcopy(repSh)
                                        newInsert.position = (sh2.position[0]-x, sh2.position[1]-y)
                                        if sh2.position[1]-y<0:
                                            newInsert.position = (sh2.position[0], 0)
                                            newInsert.m = newInsert.m[::,y-sh2.position[1]:]
                                            newInsert.shape = newInsert.m.shape
                                        if sh2.position[0]-x<0:
                                            newInsert.position = (0, sh2.position[1])
                                            newInsert.m = newInsert.m[x-sh2.position[0]:,:]
                                            newInsert.shape = newInsert.m.shape
                                        m=insertShape(m, newInsert)




%%%%%%%%%%%%%%%%%%%%%%%%%



def replicateShapes(matrix, attributes=None, diagonal=False, multicolor=True, anchorType=None, anchorColor=0,\
                    mirror=None, rotate=0, allCombs=False, scale=False, deleteOriginal=False, adoptAnchorColor=False):
    m = matrix.m.copy()
    score = -1
    #first find the shape or shapes to replicate
    if diagonal:
        if multicolor:
            shList = matrix.multicolorDShapes
        else:
            shList = matrix.dShapes
    else:
        if multicolor:
            shList = matrix.multicolorShapes
        else:
            shList = matrix.shapes
    if attributes != None:
        repList = []
        attrList = matrix.getShapeAttributes(backgroundColor=matrix.backgroundColor,\
                                             singleColor=not multicolor, diagonals=diagonal)
        for shi in range(len(shList)):
            if len(attrList[shi].intersection(attributes)) > score:
                repList = [[shList[shi]]]
                score = len(attrList[shi].intersection(attributes))
            elif len(attrList[shi].intersection(attributes)) == score:
                repList += [[shList[shi]]]
        if len(repList) == 0:
            return m
    else:
        if multicolor:
            repList = [[sh] for sh in shList]
        else:
            repList = [[sh] for sh in shList if sh.color != matrix.backgroundColor]
    delList = [sh for sh in repList]
    if allCombs:
        newList = []
        for repShapes in repList:
            newSubList = []
            for repShape in repShapes:
                for r in range(0,4):
                    mr, mrM = np.rot90(repShape.m, r), np.rot90(repShape.m[::-1,::], r)
                    newRep, newRepM = copy.deepcopy(repShape), copy.deepcopy(repShape)
                    newRep.m, newRepM.m = mr, mrM
                    newRep.shape, newRepM.shape = mr.shape, mrM.shape
                    newSubList.append(newRep)
                    newSubList.append(newRepM)
            newList.append(newSubList)
        repList = newList
    
    elif mirror == 'lr' and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = repList[0][0].m[::,::-1]
        repList = [[newRep]]
    elif mirror == 'ud' and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = repList[0][0].m[::-1,::]
        repList = [[newRep]]
    elif rotate > 0 and len(repList) == 1:
        newRep = copy.deepcopy(repList[0][0])
        newRep.m = np.rot90(repList[0][0].m,rotate)
        newRep.shape = newRep.m.shape
        repList = [[newRep]]
    if scale == True:
        newRepList=[]
        for sc in range(4,0,-1):    
            for repShape in repList:
                newRep = copy.deepcopy(repShape[0])
                newRep.m = np.repeat(np.repeat(repShape[0].m, sc, axis=1), sc, axis=0)
                newRep.shape = newRep.m.shape
                newRep.pixels = set([(i,j) for i,j in np.ndindex(newRep.m.shape) if newRep.m[i,j]!=255])
                newRepList.append(newRep)
        repList = [newRepList]
    if anchorType == 'all':
        repList.sort(key=lambda x: len(x[0].pixels), reverse=True)
    elif anchorType == 'subframe':
        repList.sort(key=lambda x: len(x[0].pixels))
    #then find places to replicate
    if anchorType == 'all':    
        for repShs in repList:
            for repSh in repShs:
                for j in range(matrix.shape[1] - repSh.shape[1]+1):
                    for i in range(matrix.shape[0] - repSh.shape[0]+1):
                        if np.all(np.logical_or(m[i:i+repSh.shape[0],j:j+repSh.shape[1]]==anchorColor,repSh.m==255)):
                            newInsert = copy.deepcopy(repSh)
                            newInsert.position = (i, j)
                            m = insertShape(m, newInsert)
                            
    elif anchorType == 'subframe':
        delList = []
        for sh2 in shList:
            if sh2 in repList:
                continue
            score, bestScore= 0, 0
            bestSh = None
            for repShs in repList:
                for repSh in repShs:
                    if sh2.isSubshape(repSh,sameColor=not adoptAnchorColor,rotation=False,mirror=False) and len(sh2.pixels)<len(repSh.pixels):
                        for x in range((repSh.shape[0]-sh2.shape[0])+1):
                            for y in range((repSh.shape[1]-sh2.shape[1])+1):
                                mAux = m[max(sh2.position[0]-x, 0):min(sh2.position[0]-x+repSh.shape[0], m.shape[0]), max(sh2.position[1]-y, 0):min(sh2.position[1]-y+repSh.shape[1], m.shape[1])]
                                shAux = repSh.m[max(0, x-sh2.position[0]):min(repSh.shape[0],m.shape[0]+x-sh2.position[0]),max(0, y-sh2.position[1]):min(repSh.shape[1],m.shape[1]+y-sh2.position[1])]
                                if np.all(np.logical_or(mAux==shAux, mAux == matrix.backgroundColor)):
                                    score = np.count_nonzero(mAux==shAux)
                                    if score > bestScore:
                                        bestScore = score
                                        bestX, bestY = sh2.position[0]-x, sh2.position[1]-y
                                        bestSh = copy.deepcopy(repSh)
            if bestSh != None:
                delList += [[bestSh]]
                newInsert = copy.deepcopy(bestSh)
                newInsert.position = (bestX, bestY)
                newInsert.shape = newInsert.m.shape
                m=insertShape(m, newInsert)
        #repList = [sh for sh in newRepList]
        
    if deleteOriginal:
        for shs in delList:
            for sh in shs:
                m = deleteShape(m, sh, matrix.backgroundColor)              
    return(m)

------------------------SYMETREIZEEEEEE__-


def symmetrizeNonbackgroundSubmatrix(matrix, ud=False, lr=False, rotation=False, newColor=None):
    """
    Given a Task.Matrix, make the non-background part symmetric
    """
    m = matrix.m.copy()
    bC = matrix.backgroundColor
    if np.all(m == bC):
        return m
    x1, x2, y1, y2 = 0, m.shape[0]-1, 0, m.shape[1]-1
    while x1 <= x2 and np.all(m[x1,:] == bC):
        x1 += 1
    while x2 >= x1 and np.all(m[x2,:] == bC):
        x2 -= 1
    while y1 <= y2 and np.all(m[:,y1] == bC):
        y1 += 1
    while y2 >= y1 and np.all(m[:,y2] == bC):
        y2 -= 1
    subMat = m[x1:x2+1,y1:y2+1].copy()
    
    found = False
    for d in range(min(subMat.shape[0], subMat.shape[1]), 0, -1):
        for x in range(subMat.shape[0]-d+1):
            for y in range(subMat.shape[1]-d+1):
                if ud and lr and np.all(subMat[x:x+d,y:y+d] == np.flipud(subMat[x:x+d,y:y+d]))\
                        and np.all(subMat[x:x+d,y:y+d] == np.fliplr(subMat[x:x+d,y:y+d]))\
                        and not np.all(subMat[x:x+d,y:y+d] == matrix.backgroundColor)\
                        and np.all(subMat[x:x+d,y:y+d] == np.rot90(subMat[x:x+d,y:y+d])):
                    found = True   
                    break
                elif rotation and np.all(subMat[x:x+d,y:y+d] == np.rot90(subMat[x:x+d,y:y+d],1))\
                        and not np.all(subMat[x:x+d,y:y+d] == matrix.backgroundColor):
                    found = True   
                    break
            if found:
                break
        if found:
            break
        
    if ud and lr:
        if 2*x+x1+d > m.shape[0] or 2*y+y1+d > m.shape[1]:
            return m
        for i in range(subMat.shape[0]):
            for j in range(subMat.shape[1]):
                if subMat[i][j] != bC:
                    m[2*x+x1+d-i-1,y1+j] = subMat[i,j]
                    m[x1+i,2*y+y1+d-j-1] = subMat[i,j]
                    m[2*x+x1+d-i-1,2*y+y1+d-j-1] = subMat[i,j]
    elif rotate:
        #if x1+y+subMat.shape[0]> m.shape[0] or y1+x+subMat.shape[1]> m.shape[1]\
        if x1+y+subMat.shape[0] > m.shape[0] or y1+x+subMat.shape[1]> m.shape[1]\
            or y1+y-x+subMat.shape[0]>= m.shape[0] or x1+x-y+subMat.shape[1]>=m.shape[1]:
            return m
        for i in range(subMat.shape[0]):
            for j in range(subMat.shape[1]):
                if subMat[i][j] != bC:
                    m[x1+x+d+y-j-1,y1+y-x+i] = subMat[i,j]
                    m[x1+x-y+j,y1+y+d+x-i-1] = subMat[i,j]
                    m[x1+2*x+d-i-1,y1+2*y+d-j-1] = subMat[i,j]        
    return m


def getBestSymmetrizeSubmatrixOld(t):
    croppedSamples = [cropAllBackground(s.outMatrix) for s in t.trainSamples]
    if all(np.all(np.flipud(m)==m) for m in croppedSamples):
        if all(np.all(np.fliplr(m)==m) for m in croppedSamples):
            return partial(symmetrizeNonbackgroundSubmatrix,ud=True, lr=True)
    if all(m.shape[0]==m.shape[1] and np.all(np.rot90(m)==m) for m in croppedSamples):
        return partial(symmetrizeNonbackgroundSubmatrix,rotation=True)
    return partial(identityM)